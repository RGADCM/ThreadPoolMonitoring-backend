# ThreadPoolMonitoring-backend

Данный проект родился из идеи разделения выполнения задач в приложении на две части:
1. Быстрые и важные операции, выполняются в пуле потоков "MainThreadPool";
2. Долгие и менее важные операции, выполняются в пуле потоков "BackgroundThreadPool"

На текущий момент разработаны два пула, которые должны использоваться при выполнении операций, пока указываются вручную через квалифаер. 
Для каждого пула используются свои настройки, включая приоретизацию потоков через соответствующую фабрику. 

Для визуализации всех процессов создан эмулятор с фронтэнд частью: https://github.com/RGADCM/ThreadPoolMonitoring-frontend. 

# Задачи для дальнейшей разработки
1. Указать MainThreadPool как основной для всего приложения "из коробки";
2. Реализовать автоматическое увеличение/уменьшение пула и очереди в зависимости от нагрузки, а так же необходимости буферизации. Реализацию
произвести на основе переодического мониторинга ресурсов железа и ОС. К примеру: у нас заполнена вся очередь и все потоки, но не загружен ЦПУ и ядра,
соответственно необходимо в реал тайме произвести увеличения допустимого количества Threads. После спада нагрузки, уменьшить пул до исходного;
3. Реализовать подключение механизма ForkJob, аналогичному ForkJoinPool;
4. Подключить базу данных для полноценных задач, убрать эмуляцию через Thread.sleep, сделать реальную нагрузку;
5. Добавить Spring Batch, по умолчанию использующий BackroundTaskPool, для выполнения самых тяжелых и долгих задач;
6. Создать механизм отслеживания блокировок при использования нескольких уровней вложенности CompleatableFuture;

# Демонстрация в совокупности с фронтэндом
![ExecutorsPool](https://github.com/RGADCM/ThreadPoolMonitoring-backend/assets/14126244/4d736637-39ac-4cfe-8a79-f0ec538c928e)
